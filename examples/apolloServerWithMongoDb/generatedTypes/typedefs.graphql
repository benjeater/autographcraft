# This file has been generated by AutoGraph. Do not edit this file directly.
# Any changes made to this file will be overwritten when AutoGraphCraft is next run.

type User {
  id: ID!
  createdAt: ISO8601DateTime!
  updatedAt: ISO8601DateTime!
  deletedAt: ISO8601DateTime
  salutation: String
  firstName: String!
  lastTime: String!
  pronouns: String
  subscriptions(filter: UserSubscriptionListFilter, sort: [UserSubscriptionSortInput!], limit: Int, nextToken: String): ListUserSubscriptionResponse
  floaty: Float
}

type UserSubscription {
  id: ID!
  userId: ID!
  user: User
  subscriptionName: String!
  startDate: ISO8601DateTime!
  expirationDate: ISO8601DateTime
  createdAt: ISO8601DateTime!
  updatedAt: ISO8601DateTime!
  deletedAt: ISO8601DateTime
}

input IDInput {
  eq: ID
  ne: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID!]
  notIn: [ID!]
  between: [ID!]
  exists: Boolean
}

input IntInput {
  eq: Int
  ne: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int!]
  notIn: [Int!]
  between: [Int!]
  exists: Boolean
}

input FloatInput {
  eq: Float
  ne: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  in: [Float!]
  notIn: [Float!]
  between: [Float!]
  exists: Boolean
}

input StringInput {
  eq: String
  ne: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  notIn: [String!]
  startsWith: String
  between: [String!]
  exists: Boolean
}

input BooleanInput {
  eq: Boolean
  ne: Boolean
  exists: Boolean
}

scalar ISO8601DateTime

input ISO8601DateTimeInput {
  eq: ISO8601DateTime
  ne: ISO8601DateTime
  le: ISO8601DateTime
  lt: ISO8601DateTime
  ge: ISO8601DateTime
  gt: ISO8601DateTime
  between: [ISO8601DateTime!]
  exists: Boolean
}

input UserCreateInput {
  salutation: String
  firstName: String!
  lastTime: String!
  pronouns: String
  floaty: Float
}

type Mutation {
  createUser(input: UserCreateInput!): User
  updateUser(input: UserUpdateInput!): User
  deleteUser(id: ID!): User
  createUserSubscription(input: UserSubscriptionCreateInput!): UserSubscription
  updateUserSubscription(input: UserSubscriptionUpdateInput!): UserSubscription
  deleteUserSubscription(id: ID!): UserSubscription
}

input UserUpdateInput {
  id: ID!
  salutation: String
  firstName: String
  lastTime: String
  pronouns: String
  floaty: Float
}

input UserDeleteInput {
  id: ID!
}

type Query {
  readUser(id: ID!): User
  listUser(filter: UserListFilter, sort: [UserSortInput!], limit: Int, nextToken: String): ListUserResponse
  readUserSubscription(id: ID!): UserSubscription
  listUserSubscription(filter: UserSubscriptionListFilter, sort: [UserSubscriptionSortInput!], limit: Int, nextToken: String): ListUserSubscriptionResponse
}

input UserListFilter {
  id: IDInput
  createdAt: ISO8601DateTimeInput
  updatedAt: ISO8601DateTimeInput
  deletedAt: ISO8601DateTimeInput
  salutation: StringInput
  firstName: StringInput
  lastTime: StringInput
  pronouns: StringInput
  floaty: FloatInput
  and: [UserListFilter]
  or: [UserListFilter]
  not: UserListFilter
}

enum UserSortField {
  id
  createdAt
  updatedAt
  deletedAt
  salutation
  firstName
  lastTime
  pronouns
  floaty
}

input UserSortInput {
  field: UserSortField!
  direction: SortDirection!
}

enum SortDirection {
  ASC
  DESC
}

type ListUserResponse {
  results: [User]!
  nextToken: String
}

input UserSubscriptionCreateInput {
  userId: ID!
  subscriptionName: String!
  startDate: ISO8601DateTime!
  expirationDate: ISO8601DateTime
}

input UserSubscriptionUpdateInput {
  id: ID!
  userId: ID
  subscriptionName: String
  startDate: ISO8601DateTime
  expirationDate: ISO8601DateTime
}

input UserSubscriptionDeleteInput {
  id: ID!
}

input UserSubscriptionListFilter {
  id: IDInput
  userId: IDInput
  subscriptionName: StringInput
  startDate: ISO8601DateTimeInput
  expirationDate: ISO8601DateTimeInput
  createdAt: ISO8601DateTimeInput
  updatedAt: ISO8601DateTimeInput
  deletedAt: ISO8601DateTimeInput
  and: [UserSubscriptionListFilter]
  or: [UserSubscriptionListFilter]
  not: UserSubscriptionListFilter
}

enum UserSubscriptionSortField {
  id
  userId
  subscriptionName
  startDate
  expirationDate
  createdAt
  updatedAt
  deletedAt
}

input UserSubscriptionSortInput {
  field: UserSubscriptionSortField!
  direction: SortDirection!
}

type ListUserSubscriptionResponse {
  results: [UserSubscription]!
  nextToken: String
}

schema {
  query: Query
  mutation: Mutation
}